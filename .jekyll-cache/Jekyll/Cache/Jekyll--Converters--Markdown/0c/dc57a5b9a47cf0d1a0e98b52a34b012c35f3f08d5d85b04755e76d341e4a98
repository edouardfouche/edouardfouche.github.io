I"˝K<p>Concept drift is a well-known issue in the data stream community. It means that the statistical properties of a data stream can change over time in unforeseen ways. In this article, I will talk about concept drift and its relation to the outlier detection problem. I will also introduce a prototype in R that can be used to simulate several kinds of drift.</p>

<h2 id="what-is-concept-drift">What is Concept Drift?</h2>

<p><a href="https://en.wikipedia.org/wiki/Concept_drift">Concept drift</a> has become a buzzword in data stream mining. It means that a change occurs in a time-dependent data flow, such that the description (either statistical or informal, qualitative) of <em>concepts</em> that are known currently might change in the future. This is interesting, because it can be understood intuitively. For example, in cyber-security the nature of cyber-attacks might change over time. It is a consequence of security patches, making selected attack vectors unusable, or new software introducing so far unknown security faults. As a result, the statistical properties of the underlying data change, and the anomaly detection models trained on aging data might show a loss in precision on new instances, if they are not correctly adapted.</p>

<p>Concept drift can be characterized differently, depending on its properties. If concept drift affects the boundaries of an underlying learning algorithms - i.e., the posterior probabilities have changed - it is said to be <strong>real</strong>. On the contrary, if it is not influencing the decision boundaries it is <strong>virtual</strong>.</p>

<p>Concept drift can also be of different types:</p>
<ul>
  <li><strong>Sudden</strong> concept drift (sometimes called concept shift<sup id="fnref:fn3" role="doc-noteref"><a href="#fn:fn3" class="footnote" rel="footnote">1</a></sup> <sup id="fnref:fn10" role="doc-noteref"><a href="#fn:fn10" class="footnote" rel="footnote">2</a></sup>) characterizes abrupt changes of concepts.</li>
  <li><strong>Gradual</strong> concept drift contains a transition phase, where the instances are generated by a mixture of a current concept and the next concept, and this proportion varies gradually through time until all instances are generated by the next concept.</li>
  <li><strong>Incremental</strong> concept drift is characterized by a incremental modification of the current concept toward a future concept.</li>
  <li>Concept drift can be <strong>recurrent</strong>. It means that a concept from the past might reappear again in the future. This recurrence can be <strong>cyclic</strong>.</li>
  <li>Concept drift can be <strong>local</strong> or <strong>global</strong><sup id="fnref:fn1" role="doc-noteref"><a href="#fn:fn1" class="footnote" rel="footnote">3</a></sup>. Local concept drift affects only a small region of the feature space, and they are thus harder to detect than global drifts. <strong>Feature drift</strong><sup id="fnref:fn2" role="doc-noteref"><a href="#fn:fn2" class="footnote" rel="footnote">4</a></sup> is also used to characterize drifts that affect only a subset of attributes.</li>
</ul>

<p>The following figure illustrates the main types of concept drifts:</p>

<p><img src="/img/concept-drift/conceptdrift.png" alt="concept-drift" class="img-responsive" style="margin: auto" /></p>

<p>Quite often, concept drifts are a combination of all the above described types. Typically, concurrent drifts take place in multi-dimensional data streams and the characteristics of those drifts are unknown a priori.</p>

<p>From the literature, its seems that <em>concept drift</em> is quite well understood. This survey<sup id="fnref:fn4" role="doc-noteref"><a href="#fn:fn4" class="footnote" rel="footnote">5</a></sup> contains a rather compact description of the different types of concept drift, while this work<sup id="fnref:fn5" role="doc-noteref"><a href="#fn:fn5" class="footnote" rel="footnote">6</a></sup> provides a comprehensive taxonomy. In this survey<sup id="fnref:fn6" role="doc-noteref"><a href="#fn:fn6" class="footnote" rel="footnote">7</a></sup> also, the different approaches to adapt to concept drift are reviewed.</p>

<h2 id="concept-drift-in-outlier-detection">Concept Drift in Outlier Detection</h2>

<p>Outlier detection can be considered as a subclass of the <em>classification</em> problem. Outlier detection is distinct from classification for the following reasons:</p>
<ul>
  <li>The classes (outlier/non outlier) are highly imbalanced, since outliers are rare.</li>
  <li>There may not be a rule to describe all the outlying instances, because they can be outlying in different ways. Their common distinction is that they are different from other data points, in some way.</li>
  <li>The characteristics of outliers/anomalies are unknown beforehand. Which leads to the impossibility to rely completely on ground truth.</li>
  <li>In real-time setting, labels may not be available in a timely manner. One typically need to investigate first before declaring a point as an outlier.</li>
</ul>

<p>As a result, outlier detection is often treated as an <em>unsupervised</em> problem.</p>

<p>Concept drift can impact outlier detection. For example, a point that may be considered as an outlier at time \(t_{1}\) may not be seen as an outlier at time \(t_{2}\) anymore.</p>

<p>There exist tools to generate data to reflect concept drift. The MOA<sup id="fnref:fn8" role="doc-noteref"><a href="#fn:fn8" class="footnote" rel="footnote">8</a></sup> framework includes several drifting data stream generators based for example on rotating hyperplanes or radial basis functions.</p>

<p>There exist also ways to generate data sets with outlier. The most common method is to start from a multi-class problem and to downsample one of the class. Then, the instances of this class become rare. Note that the relevance of such procedure in outlier detection is arguable, because all ‚Äúoutliers‚Äù are then tied to a same underlying concept: The class they originally belong to.</p>

<p>Nonetheless, there are - to the best of my knowledge - no generation procedure available to generate data with outliers subject concept drift. Particularly interesting are the so-called <em>hidden</em> outliers, because they can only be seen in particular subspace, so their detection is not trivial. I gave an example of what a hidden outlier is in a precedent <a href="https://edouardfouche.com/Neural-based-Outlier-Discovery/">article</a>, that I am going to display here again:</p>

<p><img src="/img/neural-based-outlier-discovery/3d-plot-outlier.svg" alt="3d-plot-outlier" class="img-responsive" /></p>

<p>In this 3-dimensional space, the points in red can be considered as <em>hidden</em> outliers, because they will be invisible as such in any 2-D or 1-D projections. Such outliers are in regions of relatively low density, but they cannot be detected in the full dimensional space because of the effects of the so-called <em>curse of dimensionality</em>, which destroys the notion of neighborhood<sup id="fnref:fn7" role="doc-noteref"><a href="#fn:fn7" class="footnote" rel="footnote">9</a></sup>. To find them, one need to investigate particular subspaces. This is difficult, because the number of subspaces increases exponentially with the total number of dimensions.</p>

<p>In the following, we describe a data generator that simulates this kind of outliers, and where the dependencies in subspaces change such that the concept of outlier is drifting.</p>

<h2 id="the-data-stream-generator">The Data Stream Generator</h2>

<p>We create a number <em>N</em> of <em>m</em>-dimensional vectors. Their values are uniformly distributed between 0 and 1, except for selected subspaces, which show some kind of dependency, whose strength can change over time. To generate the dependencies, we take inspiration from the synthetic data used in the HiCS<sup id="fnref:fn9" role="doc-noteref"><a href="#fn:fn9" class="footnote" rel="footnote">10</a></sup> experiments, where dependencies are constructed by placing most data points close to the subspace axises, below a particular <em>margin</em>, creating an almost empty hypercube. Then, we let the size of this margin vary.</p>

<p>The following image illustrates a 2-D subspace where the strength of the dependency changes over time. Each image corresponds to a snapshot of the same stream at different time steps. As you can see, two outliers (in red) are visible in the third image.</p>

<p><img src="/img/concept-drift/streamgenerator.svg" alt="stream-generator" class="img-responsive" /></p>

<p>Basically, points are generated independently, with respect to parameters that change over time, characterizing the current <em>concept</em>. The parameters consist mainly in a chosen set of subspaces \(S = {S_{1}, S_{2}, ‚Ä¶, S_{i} }\) associated to a value between 0 and 1, the so-called margins \(M = M_{1}, M_{2}, ‚Ä¶, M_{i}\). A smaller margin means a stronger dependency. For a number of iteration <em>n</em>, the procedure is the following:</p>

<ul>
  <li>Generate a new <em>m</em>-dimensional vector whose values are taken uniformly from the range 0 to 1 for all <em>m</em> dimension.</li>
  <li>For each subspace \(S_{k}\), the vector has a probability \(prop\) to become an outlier in this subspace.</li>
  <li>If the vector is an outlier in subspace \(S_{k}\). We scale the value of such outlier in \(S_{k}\) to make sure that it is at a certain distance from the margin (10% of the side of the hypercube). This hinders the creation of false positives.</li>
  <li>If the vector is not an outlier in subspace \(S_{k}\), it is moved uniformly into the margins. By <em>uniformly</em>, we mean that it has an equal chance to be projected in any part of the denser area, to make sure that its density stays uniform.</li>
</ul>

<p>For a number of step \(nstep\), the set \(S\) is modified randomly and the value in \(M\) incremented/decremented uniformly to reach after a number of iteration <em>n</em> the value fixed at the next step. The result is a data stream where hypercubes of variable size in selected subspaces are formed, which potentially contain outliers. Note that the probability to find outliers in the hypercubes is proportional to the volume of the hypercube.</p>

<p>The speed at which the parameters are changed is controlled by the number of point at each step \(N = {n_{1}, n_{2}, ‚Ä¶, n_{nstep}}\) and the \(volatility\), i.e. the number of subspaces whose margin value change at each step. At the end of the generation, the labels for the produced outliers are available and contain the information in which subspace they are visible.</p>

<p>The generator is distributed on my <a href="https://github.com/edouardfouche/R-streamgenerator/">GitHub</a> as an R projet. It is powerful in a sense that it can generate high-dimensional data streams, where multiple <strong>local</strong> <strong>feature drifts</strong> occur at variable speed, from <strong>sudden</strong> to <strong>incremental</strong>. The concept drift can also be <strong>recurrent</strong> and the recurrence can be <strong>cyclic</strong>. This type of concept drift can be considered as <strong>real</strong> because the distribution of the outliers (that we try to predict) is changing with the drift. More information about the technical details of the project can be found in the <a href="https://github.com/edouardfouche/R-streamgenerator/">GitHub</a> page.</p>

<h2 id="future-work">Future work</h2>

<p>This work will be extended. It would be for example interesting to support different kind of dependencies. Especially, there are dependencies that are difficult to spot using traditional correlation measures such as Pearson and Spearman coefficients.</p>

<p>For example, the following code in R generates a donut:</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">generateDonut</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">margin</span><span class="o">=</span><span class="m">0.3</span><span class="p">){</span><span class="w">
  </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">2</span><span class="o">*</span><span class="nb">pi</span><span class="o">*</span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w">
  </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">runif</span><span class="p">(</span><span class="m">1</span><span class="p">))</span><span class="w">
  </span><span class="n">ifelse</span><span class="p">(</span><span class="n">u</span><span class="o">&gt;</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">2</span><span class="o">-</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">u</span><span class="p">)</span><span class="w">
  </span><span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">margin</span><span class="p">){</span><span class="n">r</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="n">margin</span><span class="p">)</span><span class="o">/</span><span class="n">margin</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">margin</span><span class="p">}</span><span class="w">
  </span><span class="nf">c</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="nf">cos</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="o">*</span><span class="nf">sin</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">replicate</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span><span class="w"> </span><span class="n">generateDonut</span><span class="p">())))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p style="max-width: 500px; margin: auto"><img src="/img/concept-drift/donut.svg" alt="stream-generator" class="img-responsive" /></p>

<p>Such a subspace obtains very low correlation estimates with traditional correlation measures (Pearson, Spearman, Kendall), in the order of \(10^{-2}\). Nonetheless, a dependence obviously exists and there is space - for example in the center and corners - to place hidden outliers.</p>

<p>Also, in the current implementation, concept drift takes place uniformly from a specific margin value to a new nominal margin value. Such uniformity might be unrealistic. Instead, the change could take the shape of a sigmoidal function<sup id="fnref:fn10:1" role="doc-noteref"><a href="#fn:fn10" class="footnote" rel="footnote">2</a></sup>, for example.</p>

<p>Another interesting question is, how can we keep track of dependency changes in an unknown stream efficiently? In predictive maintenance, one is interested in maintaining a set of most relevant subspaces through time, while this relevance is likely to change. This is still an open research question.</p>

<h2 id="sources">Sources</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:fn3" role="doc-endnote">
      <p>Ntoutsi, Zimek, Palpanas, Kr√∂ger, Kriegel, (2012). Density-based projected clustering over high dimensional data streams. Proc. of SDM.¬†<a href="#fnref:fn3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn10" role="doc-endnote">
      <p>Shaker &amp; H√ºllermeier (2015). Recovery analysis for adaptive learning from non-stationary data streams: Experimental design and case study. Neurocomputing.¬†<a href="#fnref:fn10" class="reversefootnote" role="doc-backlink">&#8617;</a>¬†<a href="#fnref:fn10:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:fn1" role="doc-endnote">
      <p>Minku, Yao, White. (2009) The impact of diversity on online ensemble learning in the presence of concept drift.IEEE Trans. Knowl. Data Eng.¬†<a href="#fnref:fn1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn2" role="doc-endnote">
      <p>Barddal, Gomes, Enembreck, Pfahringer, Bifet. (2016) On dynamic feature weighting for feature drifting data streams. Machine Learning and Knowledge Discovery in Databases - European Conference, ECML PKDD 2016.¬†<a href="#fnref:fn2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn4" role="doc-endnote">
      <p>Ram√≠rez-Gallego, Krawczyk, Garc√≠a, Wo≈∫niak, Herrera (2017). A survey on Data Preprocessing for Data Stream Mining: Current status and future directions. Neurocomputing.¬†<a href="#fnref:fn4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn5" role="doc-endnote">
      <p>Webb, Hyde, Cao, Nguyen, Petitjean (2016). Characterizing concept drift. Data Mining and Knowledge Discovery.¬†<a href="#fnref:fn5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn6" role="doc-endnote">
      <p>Gama, ≈Ωliobaitƒó, Bifet, Pechenizkiy, Bouchachia (2014). A survey on concept drift adaptation. ACM Computing Surveys.¬†<a href="#fnref:fn6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn8" role="doc-endnote">
      <p>Bifet, Holmes, Kirkby, Pfahringer (2010). MOA: massive online analysis. Journal for Machine Learning Research.¬†<a href="#fnref:fn8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn7" role="doc-endnote">
      <p>Beyer K., Goldstein J., Ramakrishnan R. &amp; Shaft U. (1999). <em>When is ‚Äúnearest neighbor‚Äù meaningful?</em>. International Conference on Database Theory.¬†<a href="#fnref:fn7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn9" role="doc-endnote">
      <p>Keller F., M√ºller E. &amp; B√∂hm K. (2012). <em>HiCS: High contrast subspaces for density-based outlier ranking</em>. International Conference on Data Engineering.¬†<a href="#fnref:fn9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET